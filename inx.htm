<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Book Animator</title>
<style>
:root{
  --bg:#0b0b0b;--panel:#111;--ink:#eee;--muted:#bbb;
  --line:#333;--accent:#ef4444;--ok:#34d399;--warn:#f59e0b;
}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,Arial,sans-serif;}
h1{font-size:2.6rem;margin:1.1rem 0;text-align:center}
.wrap{max-width:1200px;margin:0 auto;padding:1rem}
.topbar{display:flex;justify-content:space-between;align-items:center}
.hamb{width:64px;height:64px;border:1px solid #888;border-radius:14px;display:grid;place-items:center;background:#121212;cursor:pointer}
.hamb .line{width:30px;height:4px;background:#fff;margin:5px 0;border-radius:2px}
.badge{display:inline-block;background:#151515;border:1px solid #333;padding:.28rem .7rem;border-radius:999px;margin:.2rem .3rem;color:#ddd}
textarea{width:100%;min-height:320px;background:#0f0f0f;border:1px solid #333;border-radius:12px;color:#ddd;font-size:1.06rem;line-height:1.5;padding:1rem}
.bar{display:flex;gap:.8rem;flex-wrap:wrap;margin-top:1rem}
.btn{background:#151515;border:1px solid var(--accent);color:#eee;padding:.75rem 1rem;border-radius:12px;cursor:pointer}
.btn:hover{box-shadow:0 0 0 2px #ef44441c}
.btn.ghost{border-color:#555}
.btn.small{padding:.45rem .7rem;border-radius:10px}
.thumbs{display:grid;grid-template-columns:repeat(4,1fr);gap:.75rem;margin:1.2rem 0}
.tile{height:160px;border:1px dashed #777;border-radius:12px;background:#0f0f0f;display:grid;place-items:center;position:relative}
.tile img{width:100%;height:100%;object-fit:cover;border-radius:12px}
.tile .num{position:absolute;top:6px;left:6px;font-size:.9rem;background:#000a;padding:.1rem .4rem;border-radius:7px;border:1px solid #333}
.tile .err{position:absolute;inset:auto 6px 6px 6px;background:#000c;border:1px solid #3a3a3a;border-radius:8px;padding:.35rem .5rem;font-size:.85rem;color:#fca5a5}
.progress{position:fixed;left:0;right:0;bottom:0;background:#0d0d0d;border-top:1px solid #1a1a1a;padding:.6rem 1rem;display:flex;gap:1rem;align-items:center;flex-wrap:wrap}
.meter{flex:1;min-width:240px;height:10px;background:#1a1a1a;border-radius:999px;overflow:hidden}
.meter>div{height:100%;width:0;background:#fff;transition:width .15s ease}
.pct{min-width:64px;text-align:right;color:#bbb}
.menu,.modal{position:fixed;inset:0;display:none;align-items:flex-start;justify-content:center;padding-top:5vh;background:#0008;z-index:40}
.card{background:#111;border:1px solid #333;border-radius:16px;box-shadow:0 6px 30px #0009;padding:1rem;max-width:980px;width:92vw;max-height:82vh;overflow:auto}
.tabs{display:flex;gap:.5rem;margin-bottom:1rem}
.tabs .btn{border-color:#444}
.list{display:flex;flex-direction:column;gap:.5rem}
.item{display:flex;justify-content:space-between;align-items:center;background:#101010;border:1px solid #333;padding:.75rem 1rem;border-radius:12px}
.grid{display:grid;gap:.75rem}
.two{grid-template-columns:1fr 1fr}
small.muted{color:#aaa}

.previewWrap{display:none;place-items:center;margin:12px 0}
#previewCanvas{width:100%;max-width:960px;border:1px solid #333;border-radius:12px;background:#000}
</style>
<!-- JSZip for Export (ZIP) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
<div class="wrap" id="app">
  <div class="topbar">
    <div class="hamb" id="btnLeft" aria-label="Open left menu"><div class="line"></div><div class="line"></div><div class="line"></div></div>
    <h1>Book Animator</h1>
    <div class="hamb" id="btnRight" aria-label="Open right menu"><div class="line"></div><div class="line"></div><div class="line"></div></div>
  </div>

  <div style="display:flex;justify-content:center;gap:.4rem;margin-bottom:.6rem">
    <span class="badge">Mode: <b id="modeBadge">Simple</b></span>
    <span class="badge">Scenes: <b id="scenesBadge">0</b></span>
    <span class="badge">Status: <b id="statusBadge">Idle</b></span>
  </div>

  <h3>Paste your book text:</h3>
  <textarea id="bookText" placeholder="Paste text here…"></textarea>

  <div class="bar">
    <button class="btn" id="btnPreviewScenes">Preview Scenes</button>
    <button class="btn" style="background:var(--accent)" id="btnStart">Generate Images & Audio</button>
    <button class="btn ghost" id="btnPreviewLive">Play Synced Preview</button>
  </div>

  <div class="previewWrap" id="previewWrap">
    <canvas id="previewCanvas" width="1280" height="720"></canvas>
  </div>

  <div class="thumbs" id="thumbs"></div>
</div>

<!-- progress bar -->
<div class="progress">
  <button class="btn small" id="btnSave">Save</button>
  <button class="btn small" id="btnZip">Export (ZIP)</button>
  <button class="btn small" id="btnRenderVideo">Render Video (WebM)</button>
  <div class="meter"><div id="meterFill"></div></div>
  <div class="pct" id="pct">0%</div>
</div>

<!-- LEFT MENU -->
<div class="menu" id="leftMenu">
  <div class="card">
    <div class="tabs">
      <button class="btn small" data-tab="tChars">Characters</button>
      <button class="btn small" data-tab="tSettings">Settings</button>
      <button class="btn small" data-tab="tSecrets">Secrets</button>
      <button class="btn small" data-tab="tHelp">Help</button>
      <button class="btn small" style="margin-left:auto" id="closeLeft">Close</button>
    </div>

    <!-- Characters -->
    <section id="tChars">
      <h2>Characters</h2>
      <div id="charList" class="list"></div>
      <small class="muted">Tap <b>Edit</b> to change OpenAI voice, optional ElevenLabs voice ID, notes, and portrait.</small>
    </section>

    <!-- Settings -->
    <section id="tSettings" style="display:none">
      <h2>Settings</h2>
      <div class="grid two">
        <label class="item" style="display:grid;grid-template-columns:12rem 1fr;gap:.6rem">
          <span>Render Mode</span>
          <select id="setRenderMode">
            <option value="offline">Offline (placeholders)</option>
            <option value="online">Online AI (use proxy)</option>
          </select>
        </label>
        <label class="item" style="display:grid;grid-template-columns:12rem 1fr;gap:.6rem">
          <span>Visual Motion</span>
          <select id="setVisualMotion">
            <option>Ken Burns</option><option>Pan Left</option><option>Pan Right</option>
            <option>Zoom In</option><option>Zoom Out</option><option>Static</option>
          </select>
        </label>
        <label class="item" style="display:grid;grid-template-columns:12rem 1fr;gap:.6rem">
          <span>Art Style</span>
          <select id="setArtStyle">
            <option>Comic</option><option>Cartoon</option><option>Anime</option>
            <option>Watercolor</option><option>Ink & Wash</option><option>Digital Paint</option>
            <option>Flat Toon</option><option>Dark Fantasy</option>
          </select>
        </label>
        <label class="item" style="display:grid;grid-template-columns:12rem 1fr;gap:.6rem">
          <span>Aspect</span>
          <select id="setAspect">
            <option>16:9</option><option>9:16</option><option>1:1</option>
          </select>
        </label>
      </div>
    </section>

    <!-- Secrets -->
    <section id="tSecrets" style="display:none">
      <h2>Secrets (AI Proxy)</h2>
      <div class="grid">
        <label class="item" style="display:grid;grid-template-columns:12rem 1fr;gap:.6rem">
          <span>Proxy URL</span>
          <input id="proxyBase" placeholder="https://proxy.blindart2020.workers.dev"/>
        </label>
        <div style="display:flex;gap:.6rem;justify-content:flex-end">
          <button class="btn ghost" id="btnTestProxy">Test Proxy</button>
          <button class="btn" id="btnSaveSecrets">Save</button>
        </div>
        <small class="muted">Put your Cloudflare Worker URL here. Keys live in the Worker, not in the browser.</small>
      </div>
    </section>

    <section id="tHelp" style="display:none">
      <h2>Help</h2>
      <p>Format dialogue as <code>Character: line…</code>; everything else is Narrator. Steps: Paste → Characters → Settings → Secrets (Proxy) → Generate → Preview or Export.</p>
    </section>
  </div>
</div>

<!-- RIGHT MENU -->
<div class="menu" id="rightMenu">
  <div class="card">
    <div class="tabs">
      <button class="btn small" data-rtab="uUploads">Uploads</button>
      <button class="btn small" data-rtab="uProject">Project</button>
      <button class="btn small" style="margin-left:auto" id="closeRight">Close</button>
    </div>

    <section id="uUploads">
      <h2>Uploads</h2>
      <div class="grid two">
        <label class="item"><span>Import Characters JSON</span><input id="fileChars" type="file" accept="application/json"/></label>
        <label class="item"><span>General Uploads</span><input id="fileGeneral" type="file" multiple/></label>
      </div>
      <div id="uploadList" class="list"></div>
    </section>

    <section id="uProject" style="display:none">
      <h2>Project</h2>
      <div class="grid">
        <button class="btn small" id="btnClearThumbs">Clear Thumbnails</button>
        <button class="btn small" id="btnWipe">Wipe Local Data</button>
      </div>
    </section>
  </div>
</div>

<!-- Character editor -->
<div class="modal" id="charModal">
  <div class="card" style="max-width:820px">
    <h2>Edit Character</h2>
    <div class="grid">
      <label class="item" style="display:grid;grid-template-columns:10rem 1fr;gap:.6rem">
        <span>Name</span><input id="ceName"/>
      </label>
      <label class="item" style="display:grid;grid-template-columns:10rem 1fr;gap:.6rem">
        <span>Traits / Notes</span><input id="ceNotes" placeholder="personality, role…"/>
      </label>
      <label class="item" style="display:grid;grid-template-columns:10rem 1fr;gap:.6rem">
        <span>Voice (OpenAI)</span>
        <select id="ceVoice">
          <option value="ember">Ember</option><option value="maple">Maple</option>
          <option value="juniper">Juniper</option><option value="sage">Sage</option>
          <option value="alloy">Alloy</option><option value="verse">Verse</option>
          <option value="aria">Aria</option><option value="amber">Amber</option>
        </select>
      </label>
      <label class="item" style="display:grid;grid-template-columns:10rem 1fr;gap:.6rem">
        <span>Voice (11Labs ID)</span><input id="ce11" placeholder="optional"/>
      </label>
      <label class="item" style="display:grid;grid-template-columns:10rem 1fr;gap:.6rem">
        <span>Portrait</span><input id="cePortrait" type="file" accept="image/*"/>
      </label>
    </div>
    <div class="bar" style="justify-content:flex-end">
      <button class="btn ghost" id="ceCancel">Cancel</button>
      <button class="btn" id="ceSave">Save</button>
    </div>
  </div>
</div>

<!-- hidden canvas for WebM render -->
<canvas id="stage" width="1280" height="720" style="display:none"></canvas>

<script>
/* ========= helpers ========= */
const byId = id => document.getElementById(id);
const save = (k,v)=> localStorage.setItem(k, JSON.stringify(v));
const load = (k,def)=> { try{ return JSON.parse(localStorage.getItem(k))||def; }catch{ return def; } };
const fileToDataURL = f => new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsDataURL(f); });
const sleep = ms => new Promise(r=>setTimeout(r,ms));
function escapeHtml(s){return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}

/* ========= UI refs ========= */
const UI={
  leftBtn:byId('btnLeft'), rightBtn:byId('btnRight'),
  leftMenu:byId('leftMenu'), rightMenu:byId('rightMenu'),
  closeLeft:byId('closeLeft'), closeRight:byId('closeRight'),
  tabBtns:document.querySelectorAll('[data-tab]'),
  rtabBtns:document.querySelectorAll('[data-rtab]'),
  setRenderMode:byId('setRenderMode'),
  setVisualMotion:byId('setVisualMotion'),
  setArtStyle:byId('setArtStyle'),
  setAspect:byId('setAspect'),
  proxyBase:byId('proxyBase'),
  btnSaveSecrets:byId('btnSaveSecrets'),
  btnTestProxy:byId('btnTestProxy'),
  fileChars:byId('fileChars'),
  fileGeneral:byId('fileGeneral'),
  uploadList:byId('uploadList'),
  txt:byId('bookText'), thumbs:byId('thumbs'),
  previewScenesBtn:byId('btnPreviewScenes'),
  startBtn:byId('btnStart'),
  previewLiveBtn:byId('btnPreviewLive'),
  scenesBadge:byId('scenesBadge'), modeBadge:byId('modeBadge'),
  statusBadge:byId('statusBadge'),
  meter:byId('meterFill'), pct:byId('pct'),
  btnZip:byId('btnZip'), btnSave:byId('btnSave'),
  previewWrap:byId('previewWrap'), previewCanvas:byId('previewCanvas')
};

/* ========= persistent state ========= */
let SETTINGS = load('ba_settings', {renderMode:'offline', visualMotion:'Ken Burns', artStyle:'Comic', aspect:'16:9'});
let SECRETS  = load('ba_secrets',  {proxy:'https://proxy.blindart2020.workers.dev'});
let CHARS    = load('ba_chars', defaultCharacters());

// ASSETS: the movie plan
// images[i] -> image URL for scene i
// clips[i]  -> [{ url, when, dur, speaker }]
// sfx[i]    -> URL or null
let ASSETS   = { images:[], clips:[], sfx:[] };

/* ========= init ========= */
UI.setRenderMode.value   = SETTINGS.renderMode;
UI.setVisualMotion.value = SETTINGS.visualMotion;
UI.setArtStyle.value     = SETTINGS.artStyle;
UI.setAspect.value       = SETTINGS.aspect;
UI.proxyBase.value       = SECRETS.proxy||'https://proxy.blindart2020.workers.dev';
UI.modeBadge.textContent = SETTINGS.renderMode==='online'?'Online':'Simple';
renderCharList();

/* ========= menus ========= */
UI.leftBtn.onclick = ()=> UI.leftMenu.style.display='flex';
UI.rightBtn.onclick= ()=> UI.rightMenu.style.display='flex';
UI.closeLeft.onclick=()=> UI.leftMenu.style.display='none';
UI.closeRight.onclick=()=> UI.rightMenu.style.display='none';
UI.tabBtns.forEach(b=>b.onclick=()=>showTab(b.dataset.tab));
UI.rtabBtns.forEach(b=>b.onclick=()=>showRTab(b.dataset.rtab));
function showTab(id){ ['tChars','tSettings','tSecrets','tHelp'].forEach(k=>byId(k).style.display=(k===id?'block':'none')); }
function showRTab(id){ ['uUploads','uProject'].forEach(k=>byId(k).style.display=(k===id?'block':'none')); }

/* ========= settings & secrets ========= */
UI.btnSaveSecrets.onclick=()=>{
  SECRETS.proxy = (UI.proxyBase.value.trim()||'https://proxy.blindart2020.workers.dev').replace(/\/+$/,'');
  save('ba_secrets', SECRETS);
  SETTINGS.renderMode   = UI.setRenderMode.value;
  SETTINGS.visualMotion = UI.setVisualMotion.value;
  SETTINGS.artStyle     = UI.setArtStyle.value;
  SETTINGS.aspect       = UI.setAspect.value;
  save('ba_settings', SETTINGS);
  UI.modeBadge.textContent = SETTINGS.renderMode==='online'?'Online':'Simple';
  alert('Saved.');
};
UI.btnTestProxy.onclick= async ()=>{
  const base=(UI.proxyBase.value||'').replace(/\/$/,'')||'https://proxy.blindart2020.workers.dev';
  try{
    const r=await fetch(base+'/health'); alert(r.ok?'✅ Proxy reachable':'❌ Proxy error');
  }catch(e){ alert('❌ Proxy unreachable'); }
};

/* ========= uploads ========= */
UI.fileChars.onchange=async e=>{
  const f=e.target.files[0]; if(!f)return;
  try{
    const data = JSON.parse(await f.text());
    save('ba_chars', data); CHARS=data; renderCharList(); alert('Characters imported!');
  }catch{ alert('Invalid characters.json'); }
};
UI.fileGeneral.onchange=e=>{
  const files=[...e.target.files]; UI.uploadList.innerHTML='';
  files.forEach(f=>{
    const row=document.createElement('div'); row.className='item';
    row.textContent=f.name+' ('+Math.round(f.size/1024)+' KB)';
    UI.uploadList.appendChild(row);
  });
};

/* ========= characters UI ========= */
function defaultCharacters(){
  const names=['Narrator','Sidetracked Sally','Darling Danielle','Dark Dan','Skater Skip','Creative Callie','Zen Zena','Grumpy Gus','Journey Mark','Abby','Bear'];
  // default OpenAI voice: ember
  return names.map(n=>({name:n, notes:'', voice:'ember', eleven:'', portrait:''}));
}
function renderCharList(){
  const list = byId('charList'); list.innerHTML='';
  CHARS.forEach((c,ix)=>{
    const el=document.createElement('div'); el.className='item';
    el.innerHTML = `
      <div>
        <div style="font-weight:700">${escapeHtml(c.name)}</div>
        <div style="color:#bbb;font-size:.9rem">OpenAI: ${escapeHtml(c.voice||'ember')}${c.eleven?` · 11Labs:${escapeHtml(c.eleven)}`:''}</div>
      </div>
      <div style="display:flex;gap:.5rem">
        <button class="btn small" data-edit="${ix}">Edit</button>
      </div>`;
    list.appendChild(el);
  });
  list.querySelectorAll('[data-edit]').forEach(b=>b.onclick=()=>openChar(+b.dataset.edit));
}
function openChar(ix){
  const c=CHARS[ix];
  showCharModal(true);
  byId('ceName').value=c.name; byId('ceNotes').value=c.notes||''; byId('ceVoice').value=c.voice||'ember';
  byId('ce11').value=c.eleven||''; byId('cePortrait').value='';
  editingIx = ix;
}
function showCharModal(v){ byId('charModal').style.display=v?'flex':'none'; }
let editingIx = -1;
byId('ceCancel').onclick=()=> showCharModal(false);
byId('ceSave').onclick=async ()=>{
  const c=CHARS[editingIx];
  c.name   = byId('ceName').value.trim()||c.name;
  c.notes  = byId('ceNotes').value.trim();
  c.voice  = byId('ceVoice').value;
  c.eleven = byId('ce11').value.trim();
  const f=byId('cePortrait').files?.[0];
  if(f) c.portrait = await fileToDataURL(f);
  save('ba_chars', CHARS); renderCharList(); showCharModal(false);
};

/* ========= scenes ========= */
UI.previewScenesBtn.onclick = ()=> updateSceneTiles();
function splitScenes(text){
  const blocks = text.split(/\n{2,}/).map(s=>s.trim()).filter(Boolean);
  return blocks.length?blocks:[];
}
function updateSceneTiles(){
  const scenes=splitScenes(UI.txt.value);
  UI.scenesBadge.textContent=scenes.length;
  UI.thumbs.innerHTML=''; scenes.forEach((_,i)=> UI.thumbs.appendChild(makeTile(i+1)));
}
function makeTile(n){
  const t=document.createElement('div'); t.className='tile';
  t.innerHTML = `<div class="num">#${n}</div><span style="color:#ccc">waiting…</span>`;
  return t;
}

/* ========= dialogue parsing ========= */
function parseDialogue(sceneText){
  const lines = sceneText.split(/\n+/).map(s=>s.trim()).filter(Boolean);
  const out = [];
  for(const line of lines){
    const m = line.match(/^([^:]{1,60}):\s*(.+)$/); // "Name: text"
    if(m){ out.push({speaker:m[1].trim(), text:m[2].trim()}); }
    else { out.push({speaker:'Narrator', text: line}); }
  }
  return out;
}
function findCharByName(name){
  const n = (name||'').toLowerCase();
  return CHARS.find(c=>c.name.toLowerCase()===n) ||
         CHARS.find(c=>n && c.name.toLowerCase().startsWith(n)) ||
         CHARS.find(c=>/^narrator$/i.test(c.name)) ||
         CHARS[0];
}

/* ========= proxy helpers ========= */
function getProxyBase(){
  const base = (SECRETS.proxy||'https://proxy.blindart2020.workers.dev').replace(/\/+$/,'');
  return base;
}
async function callProxy(path,{method='POST',json=null,qs=null,expect='json'}={}){
  const base=getProxyBase();
  const q=qs?('?'+new URLSearchParams(qs).toString()):'';
  const url=`${base}${path}${q}`;
  const res=await fetch(url,{method,headers:json?{'Content-Type':'application/json'}:undefined,body:json?JSON.stringify(json):undefined});
  if(!res.ok){ throw new Error(`${path} ${res.status}`); }
  if(expect==='blob') return await res.blob();
  return await res.json();
}
// Worker endpoints (blob responses)
async function genImage(prompt,style,aspect){
  const blob = await callProxy('/images',{json:{prompt,style,aspect}},null,'blob');
  return URL.createObjectURL(blob);
}
async function ttsOpenAI(text,voice='ember'){
  const blob = await callProxy('/voice/openai',{json:{text,voice}},null,'blob');
  return URL.createObjectURL(blob);
}
async function ttsEleven(text,voice_id){
  const blob = await callProxy('/voice/11labs',{json:{text,voice_id}},null,'blob');
  return URL.createObjectURL(blob);
}
async function autoSfx(text){
  const blob = await callProxy('/sfx/auto',{json:{text}},null,'blob');
  return URL.createObjectURL(blob);
}

/* ========= prompt & placeholders ========= */
function buildPrompt(scene, art){
  const base = `Illustration, ${art}, cinematic lighting, clean composition, high detail.`;
  const clean = scene.replace(/^\s*#.*$/gm,'').trim();
  return `${base}\nScene: ${clean}`;
}
async function placeholderPNG(title, subtitle=''){
  const w=640,h=360, pad=18, r=12;
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const x = c.getContext('2d');
  x.fillStyle='#0f0f0f'; x.fillRect(0,0,w,h);
  x.strokeStyle='#666'; x.lineWidth=2; roundRect(x,pad,pad,w-pad*2,h-pad*2,r); x.stroke();
  x.fillStyle='#fff'; x.font='bold 22px Inter, system-ui'; x.fillText(title, 26, 50);
  x.fillStyle='#bbb'; x.font='15px Inter, system-ui'; wrapText(x, subtitle, 26, 80, w-52, 20);
  return c.toDataURL('image/png');
}
function roundRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath();}
function wrapText(ctx, text, x, y, max, lh){
  const words=(text||'').split(/\s+/), line=[];
  for(const w of words){ const test=[...line,w].join(' '); if(ctx.measureText(test).width>max){ ctx.fillText(line.join(' '),x,y); line.length=0;y+=lh; } line.push(w); }
  ctx.fillText(line.join(' '),x,y);
}

/* ========= generation (images + audio with REAL durations) ========= */
UI.startBtn.onclick = async ()=>{
  const scenes=splitScenes(UI.txt.value);
  if(!scenes.length) return alert('Paste some text first.');
  UI.statusBadge.textContent='Generating…';
  UI.thumbs.innerHTML=''; scenes.forEach((_,i)=> UI.thumbs.appendChild(makeTile(i+1)));
  UI.meter.style.width='0%'; UI.pct.textContent='0%';
  ASSETS={images:[], clips:[], sfx:[]};

  const online = SETTINGS.renderMode==='online';
  const ACtmp = new (window.AudioContext || window.webkitAudioContext)(); // for decoding durations

  for(let i=0;i<scenes.length;i++){
    const tile = UI.thumbs.children[i];
    try{
      // IMAGE
      let imgUrl;
      if(online){
        const prompt = buildPrompt(scenes[i], SETTINGS.artStyle);
        imgUrl = await genImage(prompt, SETTINGS.artStyle, SETTINGS.aspect);
      }else{
        imgUrl = await placeholderPNG(`Scene ${i+1}`, `${SETTINGS.artStyle} • ${SETTINGS.visualMotion}`);
      }
      ASSETS.images[i]=imgUrl;
      tile.innerHTML = `<div class="num">#${i+1}</div><img alt="scene ${i+1}" src="${imgUrl}"/>`;

      // DIALOGUE with real durations
      const dialog = parseDialogue(scenes[i]);
      const clips = [];
      if(online){
        let t=0;
        for(const d of dialog){
          const ch = findCharByName(d.speaker);
          let url;
          if(ch && ch.eleven){ url = await ttsEleven(d.text, ch.eleven); }
          else { url = await ttsOpenAI(d.text, (ch && ch.voice) ? ch.voice : 'ember'); }
          const buf = await fetch(url).then(r=>r.arrayBuffer()).then(b=>ACtmp.decodeAudioData(b));
          const dur = Math.max(0.5, buf.duration);
          clips.push({url, when:t, dur, speaker:ch?.name||'Narrator'});
          t += dur + 0.12; // short gap
        }
      }
      ASSETS.clips[i]=clips;

      // SFX (best effort)
      let sfxUrl = null;
      if(online){ try{ sfxUrl = await autoSfx(scenes[i]); }catch{} }
      ASSETS.sfx[i]=sfxUrl||null;

    }catch(err){
      const msg=(err && err.message)||'Failed';
      const ph = await placeholderPNG(`Scene ${i+1}`, msg);
      ASSETS.images[i]=ph; ASSETS.clips[i]=[];
      tile.innerHTML = `<div class="num">#${i+1}</div><img src="${ph}"/><div class="err" title="${msg}">⚠ ${escapeHtml(msg).slice(0,70)}</div>`;
    }
    const p=Math.round(((i+1)/scenes.length)*100);
    UI.meter.style.width=p+'%'; UI.pct.textContent=p+'%';
    await sleep(10);
  }
  ACtmp.close();
  UI.statusBadge.textContent='Ready';
  alert('Images & audio generated. You can Preview or Export now.');
};

/* ========= LIVE PREVIEW (synced) ========= */
UI.previewLiveBtn.onclick = async ()=>{
  if(!ASSETS.images.length){ return alert('Generate first.'); }
  UI.previewWrap.style.display='grid';
  const C = UI.previewCanvas;
  setStageSizeCanvas(C, SETTINGS.aspect||'16:9');
  const ctx = C.getContext('2d');
  const fps = 60;
  const W = C.width, H = C.height;
  const imgs = await Promise.all(ASSETS.images.map(loadImg));

  const AC = new (window.AudioContext || window.webkitAudioContext)();
  const master = AC.createGain(); master.gain.value=1.0; master.connect(AC.destination);

  // Build absolute timeline length from real clips
  let totalLen = 0;
  const sceneStart = []; // absolute start time for each scene
  for(let i=0;i<ASSETS.images.length;i++){
    sceneStart[i]=totalLen;
    const clips = ASSETS.clips[i]||[];
    let sceneDur = 0;
    for(const cl of clips){ sceneDur = Math.max(sceneDur, cl.when + cl.dur); }
    sceneDur = Math.max(sceneDur, 2.0); // ensure visible even if no audio
    totalLen += sceneDur + 0.2; // pad
  }

  // schedule all audio now
  const startAt = AC.currentTime + 0.35;
  for(let i=0;i<ASSETS.images.length;i++){
    const base = sceneStart[i];
    const clips = ASSETS.clips[i]||[];
    for(const cl of clips){
      const src = AC.createBufferSource();
      const buf = await fetchDecode(AC, cl.url);
      const g = AC.createGain(); g.gain.value = 1.0;
      src.buffer = buf; src.connect(g).connect(master);
      src.start(startAt + base + cl.when);
    }
    if(ASSETS.sfx[i]){
      // low-volume sfx overlay
      const sbuf = await fetchDecode(AC, ASSETS.sfx[i]);
      const sg = AC.createGain(); sg.gain.value = 0.9;
      const ss = AC.createBufferSource(); ss.buffer = sbuf; ss.connect(sg).connect(master);
      ss.start(startAt + base);
    }
  }

  const visual = (SETTINGS && SETTINGS.visualMotion) || 'Ken Burns';
  const t0 = performance.now() + 350; // align visual to audio start
  function draw(){
    const tSec = Math.max(0, (performance.now() - t0)/1000);
    if(tSec > totalLen + 0.3){ return; }
    // find current scene
    let s=0; while(s+1<sceneStart.length && tSec >= sceneStart[s+1]) s++;
    const local = tSec - sceneStart[s];

    // compute scene duration (from clips)
    let sDur = 2.0;
    const cl = ASSETS.clips[s]||[];
    for(const c of cl){ sDur = Math.max(sDur, c.when + c.dur); }
    const tt = Math.min(1, Math.max(0, sDur ? local/sDur : 0));

    // draw
    ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
    const img = imgs[s];
    const rect = motionRect(visual, img, W, H, tt);
    ctx.drawImage(img, rect.sx, rect.sy, rect.sw, rect.sh, 0,0,W,H);

    // overlay
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(20,18,160,36);
    ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.strokeRect(20,18,160,36);
    ctx.fillStyle='#fff'; ctx.font='bold 18px system-ui,sans-serif';
    ctx.fillText(`Scene ${s+1}/${imgs.length}`, 32, 42);

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
};

/* ========= EXPORT ZIP ========= */
byId('btnZip').onclick = async ()=>{
  if(!ASSETS.images.length){ return alert('Generate first.'); }
  const zip = new JSZip();
  const manifest = {settings:SETTINGS, characters:CHARS, scenes:[]};
  for(let i=0;i<ASSETS.images.length;i++){
    const sceneRec = { image:`scene-${(i+1).toString().padStart(3,'0')}.png`, clips:[], sfx:null };
    if(ASSETS.images[i]){
      const imgBlob = await fetch(ASSETS.images[i]).then(r=>r.blob());
      zip.file(sceneRec.image, imgBlob);
    }
    const clips = ASSETS.clips[i]||[];
    for(let j=0;j<clips.length;j++){
      const fname = `scene-${(i+1).toString().padStart(3,'0')}-line-${j+1}.mp3`;
      const vBlob = await fetch(clips[j].url).then(r=>r.blob());
      zip.file(fname, vBlob);
      sceneRec.clips.push({file:fname, when:clips[j].when, dur:clips[j].dur, speaker:clips[j].speaker});
    }
    if(ASSETS.sfx[i]){
      const sBlob = await fetch(ASSETS.sfx[i]).then(r=>r.blob());
      const sname = `scene-${(i+1).toString().padStart(3,'0')}-sfx.mp3`;
      zip.file(sname, sBlob); sceneRec.sfx = sname;
    }
    manifest.scenes[i]=sceneRec;
  }
  zip.file('manifest.json', JSON.stringify(manifest,null,2));
  const blob = await zip.generateAsync({type:'blob'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='BookAnimator_Project.zip'; a.click();
};

/* ========= SAVE & WIPE ========= */
UI.btnSave.onclick = ()=>{
  save('ba_settings', SETTINGS);
  save('ba_secrets', SECRETS);
  save('ba_chars', CHARS);
  alert('Saved to this browser.');
};
byId('btnClearThumbs').onclick=()=>{ UI.thumbs.innerHTML=''; ASSETS={images:[],clips:[],sfx:[]}; };
byId('btnWipe').onclick=()=>{
  localStorage.removeItem('ba_settings');
  localStorage.removeItem('ba_secrets');
  localStorage.removeItem('ba_chars');
  alert('Cleared saved data. Reload the page.');
};

/* ========= VIDEO EXPORT (WebM) with sync ========= */
const STAGE = document.getElementById('stage');
function setStageSizeCanvas(C, aspect){
  if(aspect==='9:16'){ C.width=720; C.height=1280; }
  else if(aspect==='1:1'){ C.width=1024; C.height=1024; }
  else { C.width=1280; C.height=720; } // 16:9
}
function setStageSize(aspect){ setStageSizeCanvas(STAGE, aspect); }

document.getElementById('btnRenderVideo').onclick = async () => {
  try{
    if(!ASSETS || !ASSETS.images || ASSETS.images.length===0){
      alert('No scenes to render. Generate first.');
      return;
    }
    setStageSize(SETTINGS.aspect || '16:9');

    const fps = 24;
    const width = STAGE.width, height = STAGE.height;
    const ctx = STAGE.getContext('2d');
    STAGE.style.display = 'block';

    // compute real timing
    let totalLen = 0;
    const sceneStart = [];
    for(let i=0;i<ASSETS.images.length;i++){
      sceneStart[i]=totalLen;
      let sDur=2.0;
      for(const cl of (ASSETS.clips[i]||[])){ sDur = Math.max(sDur, cl.when + cl.dur); }
      totalLen += sDur + 0.2;
    }

    // Audio graph
    const AC = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = AC.createGain(); masterGain.gain.value = 1.0; masterGain.connect(AC.destination);

    // schedule audio
    const startAt = AC.currentTime + 0.35;
    for(let i=0;i<ASSETS.images.length;i++){
      const base = sceneStart[i];
      const clips = ASSETS.clips[i]||[];
      for(const cl of clips){
        const buf = await fetchDecode(AC, cl.url);
        const src = AC.createBufferSource(); src.buffer = buf;
        const g = AC.createGain(); g.gain.value = 1.0; src.connect(g).connect(masterGain);
        src.start(startAt + base + cl.when);
      }
      if(ASSETS.sfx[i]){
        const sb = await fetchDecode(AC, ASSETS.sfx[i]);
        const ss = AC.createBufferSource(); ss.buffer = sb;
        const sg = AC.createGain(); sg.gain.value = 0.9; ss.connect(sg).connect(masterGain);
        ss.start(startAt + base);
      }
    }

    // capture audio + canvas
    const audioStream = AC.destination.stream;
    const canvasStream = STAGE.captureStream(fps);
    const mixStream = new MediaStream([
      canvasStream.getVideoTracks()[0],
      ...(audioStream ? audioStream.getAudioTracks() : [])
    ]);

    const chunks=[];
    const mr = new MediaRecorder(mixStream, { mimeType: 'video/webm;codecs=vp9,opus' });
    mr.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
    const recDone = new Promise(res => { mr.onstop = res; });
    mr.start(100);

    const imgs = await Promise.all(ASSETS.images.map(loadImg));
    const visual = (SETTINGS && SETTINGS.visualMotion) || 'Ken Burns';

    const totalFrames = Math.ceil(totalLen * fps);
    let frame=0;
    function draw(){
      const tSec = frame / fps;
      if(tSec > totalLen + 0.05){
        setTimeout(async ()=>{
          mr.stop(); await recDone;
          const blob = new Blob(chunks, { type: 'video/webm' });
          downloadBlob(blob, 'BookAnimator_Render.webm');
          STAGE.style.display='none';
        }, 200);
        return;
      }
      // scene index
      let s=0; while(s+1<sceneStart.length && tSec >= sceneStart[s+1]) s++;
      const sLocal = tSec - sceneStart[s];
      let sDur = 2.0;
      for(const cl of (ASSETS.clips[s]||[])){ sDur = Math.max(sDur, cl.when + cl.dur); }
      const tt = Math.min(1, Math.max(0, sDur? sLocal/sDur : 0));

      // draw
      ctx.fillStyle='#000'; ctx.fillRect(0,0,width,height);
      const img = imgs[s];
      const rect = motionRect(visual, img, width, height, tt);
      ctx.drawImage(img, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, width, height);

      // HUD
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(20,18,160,36);
      ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.strokeRect(20,18,160,36);
      ctx.fillStyle='#fff'; ctx.font='bold 18px system-ui,sans-serif';
      ctx.fillText(`Scene ${s+1}/${imgs.length}`, 32, 42);

      frame++;
      UI.meter.style.width = Math.min(100, Math.round((frame/totalFrames)*100)) + '%';
      UI.pct.textContent   = Math.min(100, Math.round((frame/totalFrames)*100)) + '%';
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  }catch(err){
    alert('Video render failed: ' + (err?.message || err));
    STAGE.style.display = 'none';
  }
};

/* ========= motion + media helpers ========= */
function motionRect(mode, img, W, H, t){
  const iw = img.naturalWidth, ih = img.naturalHeight;
  const imgAR = iw/ih, canAR = W/H;
  let sw, sh;
  if (imgAR > canAR){ sh = ih; sw = sh * canAR; } else { sw = iw; sh = sw / canAR; }
  let sx = (iw - sw)/2, sy = (ih - sh)/2;

  const zoomAmt = 0.15, panAmt = 0.15;
  switch((mode||'Ken Burns').toLowerCase()){
    case 'ken burns':
    case 'zoom in': {
      const z = 1 - zoomAmt*t;
      const tw = sw*z, th = sh*z;
      const tx = sx + (sw - tw)/2, ty = sy + (sh - th)/2;
      return { sx:tx, sy:ty, sw:tw, sh:th };
    }
    case 'zoom out': {
      const z = 1 - zoomAmt*(1-t);
      const tw = sw*z, th = sh*z;
      const tx = sx + (sw - tw)/2, ty = sy + (sh - th)/2;
      return { sx:tx, sy:ty, sw:tw, sh:th };
    }
    case 'pan left':  return { sx: sx + (sw*panAmt) * t, sy, sw, sh };
    case 'pan right': return { sx: sx - (sw*panAmt) * t, sy, sw, sh };
    default:          return { sx, sy, sw, sh };
  }
}
async function fetchDecode(ctx, url){
  const res = await fetch(url);
  const buf = await res.arrayBuffer();
  return await ctx.decodeAudioData(buf);
}
function loadImg(url){
  return new Promise((res,rej)=>{ const im=new Image(); im.crossOrigin='anonymous'; im.onload=()=>res(im); im.onerror=rej; im.src=url; });
}
function downloadBlob(blob, name){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download=name;
  a.click();
}
</script>
</body>
</html>